// Copyright (C) 2018 Siavoosh Payandeh Azad, Behrad Niazmand
// ----------------------------------------------------------
//  This file is automatically generated!
//  Here are the parameters:
//       network size x: 2
//       network size y: 2
//       Data width: 32
// ----------------------------------------------------------

#include "Router_32_bit_credit_based.h"

SC_MODULE (network_2x2)
{
    sc_in <bool> reset;
    sc_in <bool> clk;
    // ------------
    // ------------
    sc_in <sc_uint<32> > RX_L_0;
    sc_out <bool> credit_out_L_0;
    sc_out <bool> valid_out_L_0;
    sc_in <bool> credit_in_L_0;
    sc_in <bool> valid_in_L_0;
    sc_out <sc_uint<32> > TX_L_0;
    // ------------
    sc_in <sc_uint<32> > RX_L_1;
    sc_out <bool> credit_out_L_1;
    sc_out <bool> valid_out_L_1;
    sc_in <bool> credit_in_L_1;
    sc_in <bool> valid_in_L_1;
    sc_out <sc_uint<32> > TX_L_1;
    // ------------
    sc_in <sc_uint<32> > RX_L_2;
    sc_out <bool> credit_out_L_2;
    sc_out <bool> valid_out_L_2;
    sc_in <bool> credit_in_L_2;
    sc_in <bool> valid_in_L_2;
    sc_out <sc_uint<32> > TX_L_2;
    // ------------
    sc_in <sc_uint<32> > RX_L_3;
    sc_out <bool> credit_out_L_3;
    sc_out <bool> valid_out_L_3;
    sc_in <bool> credit_in_L_3;
    sc_in <bool> valid_in_L_3;
    sc_out <sc_uint<32> > TX_L_3;
    
    // Generating bulk signals. Not all of them are/might be used in the design.
    sc_signal <bool> credit_out_N_0, credit_out_E_0, credit_out_W_0, credit_out_S_0;
    sc_signal <bool> credit_out_N_1, credit_out_E_1, credit_out_W_1, credit_out_S_1;
    sc_signal <bool> credit_out_N_2, credit_out_E_2, credit_out_W_2, credit_out_S_2;
    sc_signal <bool> credit_out_N_3, credit_out_E_3, credit_out_W_3, credit_out_S_3;
    
    sc_signal <bool> credit_in_N_0, credit_in_E_0, credit_in_W_0, credit_in_S_0;
    sc_signal <bool> credit_in_N_1, credit_in_E_1, credit_in_W_1, credit_in_S_1;
    sc_signal <bool> credit_in_N_2, credit_in_E_2, credit_in_W_2, credit_in_S_2;
    sc_signal <bool> credit_in_N_3, credit_in_E_3, credit_in_W_3, credit_in_S_3;
    
    sc_signal <sc_uint<32> > RX_N_0, RX_E_0, RX_W_0, RX_S_0;
    sc_signal <sc_uint<32> > RX_N_1, RX_E_1, RX_W_1, RX_S_1;
    sc_signal <sc_uint<32> > RX_N_2, RX_E_2, RX_W_2, RX_S_2;
    sc_signal <sc_uint<32> > RX_N_3, RX_E_3, RX_W_3, RX_S_3;
    
    sc_signal <bool> valid_out_N_0, valid_out_E_0, valid_out_W_0, valid_out_S_0;
    sc_signal <bool> valid_out_N_1, valid_out_E_1, valid_out_W_1, valid_out_S_1;
    sc_signal <bool> valid_out_N_2, valid_out_E_2, valid_out_W_2, valid_out_S_2;
    sc_signal <bool> valid_out_N_3, valid_out_E_3, valid_out_W_3, valid_out_S_3;
    
    sc_signal <bool> valid_in_N_0, valid_in_E_0, valid_in_W_0, valid_in_S_0;
    sc_signal <bool> valid_in_N_1, valid_in_E_1, valid_in_W_1, valid_in_S_1;
    sc_signal <bool> valid_in_N_2, valid_in_E_2, valid_in_W_2, valid_in_S_2;
    sc_signal <bool> valid_in_N_3, valid_in_E_3, valid_in_W_3, valid_in_S_3;
    
    sc_signal <sc_uint<32> > TX_N_0, TX_E_0, TX_W_0, TX_S_0;
    sc_signal <sc_uint<32> > TX_N_1, TX_E_1, TX_W_1, TX_S_1;
    sc_signal <sc_uint<32> > TX_N_2, TX_E_2, TX_W_2, TX_S_2;
    sc_signal <sc_uint<32> > TX_N_3, TX_E_3, TX_W_3, TX_S_3;
    
    // Router Modules (4 routers)
    // 2D Mesh topology, XY Routing algorithm
    router_credit_based *R_0;
    router_credit_based *R_1;
    router_credit_based *R_2;
    router_credit_based *R_3;
        
    // Process(es)
    void network_2x2_proc();
    
    SC_HAS_PROCESS(network_2x2);
    
    network_2x2(sc_module_name name_) :
    sc_module(name_)
    {        
        // Instantiating the routers
        R_0 = new router_credit_based ("R_0", 0, 60, 10, 2);
        (*R_0) (reset, clk,
                RX_N_0, RX_E_0, RX_W_0, RX_S_0, RX_L_0,
                credit_in_N_0, credit_in_E_0, credit_in_W_0, credit_in_S_0, credit_in_L_0,
                valid_in_N_0, valid_in_E_0, valid_in_W_0, valid_in_S_0, valid_in_L_0,
                valid_out_N_0, valid_out_E_0, valid_out_W_0, valid_out_S_0, valid_out_L_0,
                credit_out_N_0, credit_out_E_0, credit_out_W_0, credit_out_S_0, credit_out_L_0,
                TX_N_0, TX_E_0, TX_W_0, TX_S_0, TX_L_0);
        
        R_1 = new router_credit_based ("R_1", 1, 60, 12, 2);
        (*R_1) (reset, clk,
                RX_N_1, RX_E_1, RX_W_1, RX_S_1, RX_L_1,
                credit_in_N_1, credit_in_E_1, credit_in_W_1, credit_in_S_1, credit_in_L_1,
                valid_in_N_1, valid_in_E_1, valid_in_W_1, valid_in_S_1, valid_in_L_1,
                valid_out_N_1, valid_out_E_1, valid_out_W_1, valid_out_S_1, valid_out_L_1,
                credit_out_N_1, credit_out_E_1, credit_out_W_1, credit_out_S_1, credit_out_L_1,
                TX_N_1, TX_E_1, TX_W_1, TX_S_1, TX_L_1);
        
        R_2 = new router_credit_based ("R_2", 2, 60, 3, 2);
        (*R_2) (reset, clk,
                RX_N_2, RX_E_2, RX_W_2, RX_S_2, RX_L_2,
                credit_in_N_2, credit_in_E_2, credit_in_W_2, credit_in_S_2, credit_in_L_2,
                valid_in_N_2, valid_in_E_2, valid_in_W_2, valid_in_S_2, valid_in_L_2,
                valid_out_N_2, valid_out_E_2, valid_out_W_2, valid_out_S_2, valid_out_L_2,
                credit_out_N_2, credit_out_E_2, credit_out_W_2, credit_out_S_2, credit_out_L_2,
                TX_N_2, TX_E_2, TX_W_2, TX_S_2, TX_L_2);
        
        R_3 = new router_credit_based ("R_3", 3, 60, 5, 2);
        (*R_3) (reset, clk,
                RX_N_3, RX_E_3, RX_W_3, RX_S_3, RX_L_3,
                credit_in_N_3, credit_in_E_3, credit_in_W_3, credit_in_S_3, credit_in_L_3,
                valid_in_N_3, valid_in_E_3, valid_in_W_3, valid_in_S_3, valid_in_L_3,
                valid_out_N_3, valid_out_E_3, valid_out_W_3, valid_out_S_3, valid_out_L_3,
                credit_out_N_3, credit_out_E_3, credit_out_W_3, credit_out_S_3, credit_out_L_3,
                TX_N_3, TX_E_3, TX_W_3, TX_S_3, TX_L_3);
        
        
        SC_METHOD (network_2x2_proc);
        sensitive << TX_S_0 << TX_N_2 << TX_S_1 << TX_N_3 << TX_W_1 << TX_E_0 << TX_W_3 << TX_E_2
        << valid_out_S_0 << valid_out_N_2 << credit_out_N_2 << credit_out_S_0 << valid_out_S_1
        << valid_out_N_3 << credit_out_N_3 << credit_out_S_1 << valid_out_W_1 << valid_out_E_0
        << credit_out_E_0 << credit_out_W_1 << valid_out_W_3 << valid_out_E_2 << credit_out_E_2
        << credit_out_W_3;
    }
    
};

